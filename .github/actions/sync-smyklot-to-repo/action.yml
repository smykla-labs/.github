---
name: Sync smyklot Version to Repository
description: >-
  Update smyklot version references in workflow files

inputs:
  token:
    description: GitHub token for API access
    required: true
  org:
    description: Organization name
    required: true
  repo:
    description: Target repository name
    required: true
  version:
    description: smyklot version (e.g., 1.9.2)
    required: true
  tag:
    description: smyklot tag (e.g., v1.9.2)
    required: true
  sync-config:
    description: Parsed sync-config JSON from get-sync-config action
    required: false
    default: "{}"
  dry-run:
    description: Dry run (no changes)
    required: false
    default: "false"
  source-repo:
    description: Source repository name (where the workflow runs)
    required: false
    default: ".github"

outputs:
  pr-url:
    description: URL of created/updated PR (empty if no changes)
    value: ${{ steps.sync.outputs.pr_url }}
  updated:
    description: Number of files updated
    value: ${{ steps.sync.outputs.updated }}
  skipped:
    description: Whether repo was skipped (true/false)
    value: ${{ steps.sync.outputs.skipped }}

runs:
  using: composite
  steps:
    - name: Sync smyklot version
      id: sync
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        ORG: ${{ inputs.org }}
        REPO: ${{ inputs.repo }}
        VERSION: ${{ inputs.version }}
        TAG: ${{ inputs.tag }}
        SYNC_CONFIG: ${{ inputs.sync-config }}
        DRY_RUN: ${{ inputs.dry-run }}
        SOURCE_REPO: ${{ inputs.source-repo }}
        GITHUB_RUN_ID: ${{ github.run_id }}
      run: |
        set -euo pipefail

        echo "üîÑ Syncing smyklot version to $ORG/$REPO..."
        echo "   Version: $VERSION"
        echo "   Tag: $TAG"

        # Parse sync config
        if [ -n "$SYNC_CONFIG" ] && [ "$SYNC_CONFIG" != "{}" ]; then
          sync_skip=$(echo "$SYNC_CONFIG" | jq -r '.sync.skip // false')
          smyklot_skip=$(echo "$SYNC_CONFIG" | jq -r '.sync.smyklot.skip // false')
        else
          sync_skip="false"
          smyklot_skip="false"
        fi

        # Check skip flags
        if [ "$sync_skip" = "true" ] || [ "$smyklot_skip" = "true" ]; then
          if [ "$sync_skip" = "true" ]; then
            echo "   ‚è≠Ô∏è  Skipping: sync.skip=true in repo config"
            skip_reason="smyklot version synchronization is disabled for this repository (sync.skip=true)"
          else
            echo "   ‚è≠Ô∏è  Skipping: sync.smyklot.skip=true in repo config"
            skip_reason="smyklot version synchronization is disabled for this repository (sync.smyklot.skip=true)"
          fi

          # Check if there's an existing PR to close
          branch_name="chore/sync-smyklot"
          existing_pr=$(gh pr list --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --state open \
            --json number \
            --jq '.[0].number') || existing_pr=""

          if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
            echo "   Closing PR #$existing_pr (smyklot sync disabled)"
            gh pr close "$existing_pr" \
              --repo "$ORG/$REPO" \
              --comment "$skip_reason" \
              2>&1 || true
          fi

          echo "pr_url=" >> "$GITHUB_OUTPUT"
          echo "updated=0" >> "$GITHUB_OUTPUT"
          echo "skipped=true" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Get default branch for target repo
        default_branch=$(gh api "repos/$ORG/$REPO" --jq '.default_branch')
        echo "   Default branch: $default_branch"

        # Get current HEAD SHA for the default branch
        base_sha=$(gh api "repos/$ORG/$REPO/git/ref/heads/$default_branch" \
          --jq '.object.sha')
        echo "   Base SHA: ${base_sha:0:7}"

        # List workflow files
        echo ""
        echo "   Fetching workflow files..."
        workflows_response=$(gh api "repos/$ORG/$REPO/contents/.github/workflows" \
          --jq '.[] | select(.name | endswith(".yml") or endswith(".yaml")) | .path' \
          2>&1) || workflows_response=""

        if [ -z "$workflows_response" ]; then
          echo "   No workflow files found"
          echo "pr_url=" >> "$GITHUB_OUTPUT"
          echo "updated=0" >> "$GITHUB_OUTPUT"
          echo "skipped=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Track changes
        updated=0
        changes=()
        updated_files=()

        # Process each workflow file
        while IFS= read -r workflow_path; do
          [ -z "$workflow_path" ] && continue

          echo ""
          echo "   üìÑ Processing: $workflow_path"

          # Fetch file content
          file_response=$(gh api "repos/$ORG/$REPO/contents/$workflow_path" \
            2>&1) || continue

          if ! echo "$file_response" | jq -e '.content' > /dev/null 2>&1; then
            echo "      ‚ùå Failed to fetch content"
            continue
          fi

          file_content=$(echo "$file_response" | jq -r '.content' | base64 -d)
          file_sha=$(echo "$file_response" | jq -r '.sha')

          # Apply replacements
          # 1. GitHub Action reference (uses: smykla-labs/smyklot@v1.2.3)
          # 2. Docker image reference (ghcr.io/smykla-labs/smyklot:1.2.3)
          updated_content=$(echo "$file_content" | \
            sed -E "s|(uses:[[:space:]]*smykla-labs/smyklot@)v[0-9]+\.[0-9]+\.[0-9]+|\1$TAG|g" | \
            sed -E "s|(ghcr\.io/smykla-labs/smyklot:)[0-9]+\.[0-9]+\.[0-9]+|\1$VERSION|g")

          # Check if content changed
          if [ "$file_content" = "$updated_content" ]; then
            echo "      ‚úì No smyklot references or already up to date"
            continue
          fi

          echo "      üîÑ Found outdated smyklot references"
          updated=$((updated + 1))
          updated_files+=("$workflow_path")

          # Stage change
          encoded_content=$(echo "$updated_content" | base64 | tr -d '\n')
          changes+=("$(jq -n \
            --arg path "$workflow_path" \
            --arg content "$encoded_content" \
            --arg sha "$file_sha" \
            '{path: $path, content: $content, sha: $sha}')")
        done <<< "$workflows_response"

        echo ""
        echo "üìä Summary:"
        echo "   Updated: $updated"

        # Output counts
        echo "updated=$updated" >> "$GITHUB_OUTPUT"
        echo "skipped=false" >> "$GITHUB_OUTPUT"

        # If no changes, check for existing PR and close it
        if [ ${#changes[@]} -eq 0 ]; then
          echo ""
          echo "‚úÖ No changes needed"

          # Check if there's an existing PR to close
          branch_name="chore/sync-smyklot"
          existing_pr=$(gh pr list --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --state open \
            --json number \
            --jq '.[0].number') || existing_pr=""

          if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
            echo "   Closing PR #$existing_pr (smyklot already up to date)"
            gh pr close "$existing_pr" \
              --repo "$ORG/$REPO" \
              --comment "smyklot is already up to date. Closing this PR." \
              2>&1 || true
          fi

          echo "pr_url=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        if [ "$DRY_RUN" = "true" ]; then
          echo ""
          echo "üîç Dry run - no changes made"
          echo "pr_url=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo ""
        echo "üîß Creating PR with changes..."

        # Branch name
        branch_name="chore/sync-smyklot"

        # Check if branch exists
        existing_branch=$(gh api "repos/$ORG/$REPO/git/ref/heads/$branch_name" \
          2>&1) || true

        if echo "$existing_branch" | jq -e '.object.sha' > /dev/null 2>&1; then
          # Branch exists - check if there's a merged PR
          merged_pr=$(gh pr list --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --state merged \
            --json number \
            --jq '.[0].number' 2>/dev/null) || merged_pr=""

          if [ -n "$merged_pr" ] && [ "$merged_pr" != "null" ]; then
            echo "   Branch has merged PR #$merged_pr, deleting branch..."
            gh api "repos/$ORG/$REPO/git/refs/heads/$branch_name" -X DELETE 2>&1 || true
            # Clear existing_branch so we create a fresh one
            existing_branch=""
            echo "   Creating fresh branch: $branch_name"
            gh api "repos/$ORG/$REPO/git/refs" \
              -f ref="refs/heads/$branch_name" \
              -f sha="$base_sha" > /dev/null
          else
            echo "   Branch exists, will override commits..."
          fi
        else
          echo "   Creating branch: $branch_name"
          # Create branch from default branch HEAD
          gh api "repos/$ORG/$REPO/git/refs" \
            -f ref="refs/heads/$branch_name" \
            -f sha="$base_sha" > /dev/null
        fi

        # Create blobs and prepare tree entries
        echo "   Creating blobs..."
        tree_entries=()
        for change_json in "${changes[@]}"; do
          file_path=$(echo "$change_json" | jq -r '.path')
          encoded=$(echo "$change_json" | jq -r '.content')

          blob_sha=$(gh api "repos/$ORG/$REPO/git/blobs" \
            -f content="$encoded" \
            -f encoding="base64" \
            --jq '.sha')

          tree_entries+=("$(jq -n \
            --arg path "$file_path" \
            --arg blob "$blob_sha" \
            '{path: $path, mode: "100644", type: "blob", sha: $blob}')")
        done

        # Get base tree
        base_tree=$(gh api "repos/$ORG/$REPO/git/commits/$base_sha" \
          --jq '.tree.sha')

        # Build tree JSON with all files
        tree_array=$(printf '%s\n' "${tree_entries[@]}" | jq -s '.')
        tree_json=$(jq -n \
          --arg base "$base_tree" \
          --argjson tree "$tree_array" \
          '{base_tree: $base, tree: $tree}')

        # Create single tree with all changes
        echo "   Creating tree with all changes..."
        new_tree=$(echo "$tree_json" | \
          gh api "repos/$ORG/$REPO/git/trees" --input - --jq '.sha')

        # Check if existing branch has identical content
        if echo "$existing_branch" | jq -e '.object.sha' > /dev/null 2>&1; then
          content_changed=false

          # Compare each file's blob SHA with existing branch
          for entry_json in "${tree_entries[@]}"; do
            file_path=$(echo "$entry_json" | jq -r '.path')
            new_blob=$(echo "$entry_json" | jq -r '.sha')

            # Get existing file's blob SHA from PR branch
            existing_blob=$(gh api "repos/$ORG/$REPO/contents/$file_path?ref=$branch_name" \
              --jq '.sha' 2>/dev/null) || existing_blob=""

            if [ "$new_blob" != "$existing_blob" ]; then
              content_changed=true
              break
            fi
          done

          if [ "$content_changed" = "false" ]; then
            echo "   ‚úì Branch content unchanged, skipping branch update"
            skip_branch_update=true
          fi
        fi

        # Build PR title and body
        pr_title="chore(deps): update smyklot to $TAG"

        # Build file list for PR body
        updated_list=""
        for file in "${updated_files[@]}"; do
          updated_list="${updated_list}- \`${file}\`"$'\n'
        done

        # Build PR body
        run_url="https://github.com/$ORG/$SOURCE_REPO/actions/runs/${GITHUB_RUN_ID}"
        pr_body="Updates [\`smykla-labs/smyklot\`](https://github.com/smykla-labs/smyklot) "
        pr_body="${pr_body}to version [\`$TAG\`](https://github.com/smykla-labs/smyklot/releases/tag/$TAG)."
        pr_body="${pr_body}"$'\n\n'"## Files Updated"$'\n\n'"${updated_list}"
        pr_body="${pr_body}"$'\n'"---"$'\n\n'
        pr_body="${pr_body}"*This PR was automatically created by the smyklot sync workflow "
        pr_body="${pr_body}"(run [#${GITHUB_RUN_ID}](${run_url}))*"

        # Initialize PR variables
        pr_number=""
        pr_url=""

        # Handle content unchanged case - update PR metadata only
        if [ "${skip_branch_update:-false}" = "true" ]; then
          # Check for existing PR to update title/body
          existing_pr=$(gh pr list --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --state open \
            --json number,url \
            --jq '.[0]') || existing_pr=""

          if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
            pr_number=$(echo "$existing_pr" | jq -r '.number')
            pr_url=$(echo "$existing_pr" | jq -r '.url')

            gh pr edit "$pr_number" \
              --repo "$ORG/$REPO" \
              --title "$pr_title" \
              --body "$pr_body" \
              --add-label "ci/skip-all" \
              2>&1 || true

            echo "   Updated PR metadata: $pr_url"
            echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "   No existing PR found, will create one"
            # Don't exit - continue to PR creation below
          fi
        fi

        # Create/update branch only if content changed
        if [ "${skip_branch_update:-false}" != "true" ]; then
          # Create single commit
          commit_msg="chore(deps): update smyklot to $TAG"
          echo "   Creating commit..."
          new_commit=$(gh api "repos/$ORG/$REPO/git/commits" \
            --input <(jq -n \
              --arg msg "$commit_msg" \
              --arg tree "$new_tree" \
              --arg parent "$base_sha" \
              '{message: $msg, tree: $tree, parents: [$parent]}') \
            --jq '.sha')

          current_sha="$new_commit"

          # Update branch ref (force to override previous commits)
          gh api "repos/$ORG/$REPO/git/refs/heads/$branch_name" \
            -X PATCH \
            -f sha="$current_sha" \
            -F force=true > /dev/null

          echo "   Branch updated to: ${current_sha:0:7}"
        fi

        # Check for existing PR
        existing_pr=$(gh pr list --repo "$ORG/$REPO" \
          --head "$branch_name" \
          --state open \
          --json number,url \
          --jq '.[0]') || existing_pr=""

        if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
          # Update existing PR
          pr_number=$(echo "$existing_pr" | jq -r '.number')
          pr_url=$(echo "$existing_pr" | jq -r '.url')

          gh pr edit "$pr_number" \
            --repo "$ORG/$REPO" \
            --title "$pr_title" \
            --body "$pr_body" \
            --add-label "ci/skip-all" \
            2>&1 || true

          echo "   Updated existing PR: $pr_url"
        else
          # Create PR
          pr_result=$(gh pr create \
            --repo "$ORG/$REPO" \
            --head "$branch_name" \
            --base "$default_branch" \
            --title "$pr_title" \
            --body "$pr_body" \
            2>&1) || true

          if echo "$pr_result" | grep -q "^https://"; then
            pr_url="$pr_result"
            echo "   Created PR: $pr_url"
            # Extract PR number from URL
            pr_number=$(echo "$pr_url" | grep -oE '[0-9]+$')

            # Add label if it exists (ignore error for missing label)
            gh pr edit "$pr_number" \
              --repo "$ORG/$REPO" \
              --add-label "ci/skip-all" \
              2>&1 || echo "   ‚ö†Ô∏è  ci/skip-all label may not exist in target repo"
          else
            pr_url=""
            echo "   ‚ùå Failed to create PR"
            echo "   Error: $pr_result"
          fi
        fi

        # Enable auto-merge with squash
        if [ -n "$pr_number" ]; then
          echo "   Enabling auto-merge (squash)..."
          pr_node_id=$(gh api "repos/$ORG/$REPO/pulls/$pr_number" \
            --jq '.node_id')

          gh api graphql \
            -f query='mutation($prId: ID!) {
              enablePullRequestAutoMerge(input: {
                pullRequestId: $prId,
                mergeMethod: SQUASH
              }) {
                pullRequest {
                  autoMergeRequest {
                    enabledAt
                  }
                }
              }
            }' \
            -f prId="$pr_node_id" > /dev/null 2>&1 || \
            echo "   ‚ö†Ô∏è  Could not enable auto-merge (may require approval or checks)"
        fi

        echo "pr_url=$pr_url" >> "$GITHUB_OUTPUT"
        echo ""
        echo "‚úÖ smyklot sync complete"
